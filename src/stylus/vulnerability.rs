use super::{StylusError, Vulnerability, VulnerabilitySeverity};
use regex::Regex;

pub struct VulnerabilityScanner {
    content: String,
}

impl VulnerabilityScanner {
    pub fn new(content: String) -> Self {
        Self { content }
    }

    pub fn scan(&self) -> Result<Vec<Vulnerability>, StylusError> {
        let mut vulnerabilities = Vec::new();

        self.check_reentrancy(&mut vulnerabilities)?;
        self.check_integer_overflow(&mut vulnerabilities)?;
        self.check_access_control(&mut vulnerabilities)?;

        Ok(vulnerabilities)
    }

    fn check_reentrancy(&self, vulnerabilities: &mut Vec<Vulnerability>) -> Result<(), StylusError> {
        let external_call_pattern = Regex::new(r"call\s*\(").map_err(|e| 
            StylusError::VulnerabilityError(format!("Regex error: {}", e)))?;
        
        for (line_num, line) in self.content.lines().enumerate() {
            if external_call_pattern.is_match(line) {
                vulnerabilities.push(Vulnerability {
                    severity: VulnerabilitySeverity::High,
                    line: line_num + 1,
                    description: "Potential reentrancy vulnerability".to_string(),
                    recommendation: "Implement checks-effects-interactions pattern and use reentrancy guards".to_string(),
                });
            }
        }
        Ok(())
    }

    fn check_integer_overflow(&self, vulnerabilities: &mut Vec<Vulnerability>) -> Result<(), StylusError> {
        let arithmetic_pattern = Regex::new(r"[+\-*/]=[^=]|[+\-*/]\s+[0-9]").map_err(|e| 
            StylusError::VulnerabilityError(format!("Regex error: {}", e)))?;

        for (line_num, line) in self.content.lines().enumerate() {
            if arithmetic_pattern.is_match(line) {
                vulnerabilities.push(Vulnerability {
                    severity: VulnerabilitySeverity::Medium,
                    line: line_num + 1,
                    description: "Potential integer overflow/underflow".to_string(),
                    recommendation: "Use SafeMath library or checked arithmetic operations".to_string(),
                });
            }
        }
        Ok(())
    }

    fn check_access_control(&self, vulnerabilities: &mut Vec<Vulnerability>) -> Result<(), StylusError> {
        let public_function_pattern = Regex::new(r"pub\s+fn").map_err(|e| 
            StylusError::VulnerabilityError(format!("Regex error: {}", e)))?;

        for (line_num, line) in self.content.lines().enumerate() {
            if public_function_pattern.is_match(line) {
                vulnerabilities.push(Vulnerability {
                    severity: VulnerabilitySeverity::Low,
                    line: line_num + 1,
                    description: "Public function without access control".to_string(),
                    recommendation: "Consider adding access modifiers or role-based access control".to_string(),
                });
            }
        }
        Ok(())
    }
}

pub fn scan_vulnerabilities(content: String) -> Result<Vec<Vulnerability>, StylusError> {
    let scanner = VulnerabilityScanner::new(content);
    scanner.scan()
}
