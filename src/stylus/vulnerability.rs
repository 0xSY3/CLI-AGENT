use super::StylusError;
use regex::Regex;

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum VulnerabilitySeverity {
    Critical,
    High,
    Medium,
    Info,
}

#[derive(Debug)]
pub struct Vulnerability {
    pub severity: VulnerabilitySeverity,
    pub line: usize,
    pub description: String,
    pub recommendation: String,
    pub category: VulnerabilityCategory,
}

#[derive(Debug, Clone)]
pub enum VulnerabilityCategory {
    Reentrancy,
    IntegerOverflow,
    AccessControl,
    StateManipulation,
    DataValidation,
    LogicError,
}

pub struct VulnerabilityScanner {
    content: String,
}

impl VulnerabilityScanner {
    pub fn new(content: String) -> Self {
        Self { content }
    }

    pub fn scan(&self) -> Result<Vec<Vulnerability>, StylusError> {
        let mut vulnerabilities = Vec::new();

        self.check_reentrancy(&mut vulnerabilities)?;
        self.check_integer_overflow(&mut vulnerabilities)?;
        self.check_access_control(&mut vulnerabilities)?;
        self.check_state_manipulation(&mut vulnerabilities)?;
        self.check_data_validation(&mut vulnerabilities)?;
        self.check_logic_patterns(&mut vulnerabilities)?;

        Ok(vulnerabilities)
    }

    fn check_reentrancy(&self, vulnerabilities: &mut Vec<Vulnerability>) -> Result<(), StylusError> {
        let patterns = [
            (r"external_call\s*\([^)]*\).*self\.", 
             "External call followed by state modification",
             VulnerabilitySeverity::Critical),

            (r"call\s*\([^)]*\).*StorageMap", 
             "External call followed by storage operation",
             VulnerabilitySeverity::Critical),

            (r"transfer\s*\([^)]*\).*=", 
             "Value transfer followed by state change",
             VulnerabilitySeverity::High),
        ];

        for (line_num, line) in self.content.lines().enumerate() {
            for (pattern, desc, severity) in &patterns {
                if let Ok(regex) = Regex::new(pattern) {
                    if regex.is_match(line) {
                        vulnerabilities.push(Vulnerability {
                            severity: severity.clone(),
                            line: line_num + 1,
                            description: desc.to_string(),
                            recommendation: "Implement checks-effects-interactions pattern and use reentrancy guards.".to_string(),
                            category: VulnerabilityCategory::Reentrancy,
                        });
                    }
                }
            }
        }
        Ok(())
    }

    fn check_integer_overflow(&self, vulnerabilities: &mut Vec<Vulnerability>) -> Result<(), StylusError> {
        let patterns = [
            (r"[+\-*/]=", "Arithmetic operation without overflow check", VulnerabilitySeverity::High),
            (r"\+\+|\-\-", "Increment/decrement operation", VulnerabilitySeverity::Medium),
            (r"u(8|16|32|64|128|size)\s*::\s*(MAX|MIN)", "Boundary value usage", VulnerabilitySeverity::High),
        ];

        for (line_num, line) in self.content.lines().enumerate() {
            for (pattern, desc, severity) in &patterns {
                if let Ok(regex) = Regex::new(pattern) {
                    if regex.is_match(line) {
                        vulnerabilities.push(Vulnerability {
                            severity: severity.clone(),
                            line: line_num + 1,
                            description: format!("Potential integer overflow/underflow: {}", desc),
                            recommendation: "Use checked arithmetic operations or the num_traits crate.".to_string(),
                            category: VulnerabilityCategory::IntegerOverflow,
                        });
                    }
                }
            }
        }
        Ok(())
    }

    fn check_access_control(&self, vulnerabilities: &mut Vec<Vulnerability>) -> Result<(), StylusError> {
        let patterns = [
            (r"pub\s+fn\s+[^(]*\([^)]*\)", 
             "Public function without access control",
             VulnerabilitySeverity::Medium),

            (r"#\[no_mangle\]", 
             "Externally accessible function",
             VulnerabilitySeverity::High),

            (r"unsafe\s+fn", 
             "Unsafe function declaration",
             VulnerabilitySeverity::Critical),
        ];

        for (line_num, line) in self.content.lines().enumerate() {
            for (pattern, desc, severity) in &patterns {
                if let Ok(regex) = Regex::new(pattern) {
                    if regex.is_match(line) {
                        vulnerabilities.push(Vulnerability {
                            severity: severity.clone(),
                            line: line_num + 1,
                            description: desc.to_string(),
                            recommendation: "Implement role-based access control.".to_string(),
                            category: VulnerabilityCategory::AccessControl,
                        });
                    }
                }
            }
        }
        Ok(())
    }

    fn check_state_manipulation(&self, vulnerabilities: &mut Vec<Vulnerability>) -> Result<(), StylusError> {
        let patterns = [
            (r"self\.[a-zA-Z_][a-zA-Z0-9_]*\s*=\s*[^;]+;.*self\.[a-zA-Z_][a-zA-Z0-9_]*\s*=",
             "Multiple state modifications without validation",
             VulnerabilitySeverity::High),

            (r"StorageMap<.*>\.insert\([^)]*\).*StorageMap<.*>\.insert",
             "Multiple storage modifications",
             VulnerabilitySeverity::Medium),
        ];

        for (line_num, line) in self.content.lines().enumerate() {
            for (pattern, desc, severity) in &patterns {
                if let Ok(regex) = Regex::new(pattern) {
                    if regex.is_match(line) {
                        vulnerabilities.push(Vulnerability {
                            severity: severity.clone(),
                            line: line_num + 1,
                            description: desc.to_string(),
                            recommendation: "Implement state validation checks between modifications.".to_string(),
                            category: VulnerabilityCategory::StateManipulation,
                        });
                    }
                }
            }
        }
        Ok(())
    }

    fn check_data_validation(&self, vulnerabilities: &mut Vec<Vulnerability>) -> Result<(), StylusError> {
        let patterns = [
            (r"\.unwrap\(\)", 
             "Unwrap usage without error handling",
             VulnerabilitySeverity::High),

            (r"as\s+[a-zA-Z_][a-zA-Z0-9_]*", 
             "Type casting without validation",
             VulnerabilitySeverity::Medium),

            (r"panic!\s*\(", 
             "Panic usage in contract code",
             VulnerabilitySeverity::High),
        ];

        for (line_num, line) in self.content.lines().enumerate() {
            for (pattern, desc, severity) in &patterns {
                if let Ok(regex) = Regex::new(pattern) {
                    if regex.is_match(line) {
                        vulnerabilities.push(Vulnerability {
                            severity: severity.clone(),
                            line: line_num + 1,
                            description: desc.to_string(),
                            recommendation: "Implement proper error handling and input validation.".to_string(),
                            category: VulnerabilityCategory::DataValidation,
                        });
                    }
                }
            }
        }
        Ok(())
    }

    fn check_logic_patterns(&self, vulnerabilities: &mut Vec<Vulnerability>) -> Result<(), StylusError> {
        let patterns = [
            (r"if\s+true|if\s+false", 
             "Hardcoded boolean condition",
             VulnerabilitySeverity::High),

            (r"==\s*true|==\s*false", 
             "Redundant boolean comparison",
             VulnerabilitySeverity::Info),

            (r"loop\s*\{", 
             "Infinite loop potential",
             VulnerabilitySeverity::Critical),
        ];

        for (line_num, line) in self.content.lines().enumerate() {
            for (pattern, desc, severity) in &patterns {
                if let Ok(regex) = Regex::new(pattern) {
                    if regex.is_match(line) {
                        vulnerabilities.push(Vulnerability {
                            severity: severity.clone(),
                            line: line_num + 1,
                            description: desc.to_string(),
                            recommendation: "Review and fix logical errors.".to_string(),
                            category: VulnerabilityCategory::LogicError,
                        });
                    }
                }
            }
        }
        Ok(())
    }
}

pub fn scan_vulnerabilities(content: String) -> Result<Vec<Vulnerability>, StylusError> {
    let scanner = VulnerabilityScanner::new(content);
    scanner.scan()
}